#!/bin/bash

# Added check_gpp_installation() function, check below at line 85
# --- Function to get script directory ---
get_script_directory() {
    # Sets the SCRIPT_DIR variable to the script's absolute path
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
}

# --- Function to save config ---
save_config() {
    # Saves the provided LAPACK paths to the configuration file
    local CONFIG_FILE="${SCRIPT_DIR}/LAPACK_CONFIG"
    cat > "$CONFIG_FILE" << EOF
# Project configuration file
LAPACK_INCLUDE_PATH="$LAPACK_INCLUDE_PATH"
LAPACK_LIB_PATH="$LAPACK_LIB_PATH"
EOF
    echo "Configuration saved to $CONFIG_FILE"
}

# --- Function to clean previous run data ---
clean_previous_data() {
    # Removes directories generated by previous runs to ensure a clean state
    echo "Cleaning up data from previous runs..."
    local dirs_to_clean=("eigenCSV" "exportedMatrices" "graphs" "eigenPlots")
    
    for dir in "${dirs_to_clean[@]}"; do
        if [ -d "${SCRIPT_DIR}/${dir}" ]; then
            echo "Removing directory: ${SCRIPT_DIR}/${dir}"
            rm -rf "${SCRIPT_DIR}/${dir}"
        fi
    done
    echo "Cleanup completed."
}

# --- Function to check for Python dependencies ---
check_python_dependencies() {
    # This function will loop until all Python dependencies are met or the user quits.
    while true; do
        # Verifies that all required Python packages are installed
        local missing_packages=()
        for package in networkx numpy matplotlib pandas scipy numba; do
            if ! python3 -c "import $package" &> /dev/null; then
                missing_packages+=($package)
            fi
        done

        # If no packages are missing, dependencies are satisfied. Exit the function successfully.
        if [ ${#missing_packages[@]} -eq 0 ]; then
            return 0
        fi

        # If packages are missing, inform the user and prompt for action.
        echo "The following Python packages are missing: ${missing_packages[*]}"
        
        # This prompt loop will only break if the user chooses to install (y) or quit (q).
        # Choosing 'n' will keep them in this prompt loop, effectively pausing the script.
        while true; do
            read -p "The project cannot continue without these dependencies. Would you like these dependencies to be installed? (y/n/quit) " ynq
            case $ynq in
                [Yy]* )
                    echo "Installing missing packages..."
                    pip3 install "${missing_packages[@]}"
                    # After attempting installation, break the inner prompt loop.
                    # The outer `while true` will then re-run the dependency check.
                    break
                    ;;
                [Nn]* )
                    continue
                    ;;
                [Qq]* )
                    echo "Exiting..."
                    exit 0
                    ;;
                * )
                    echo "Please answer yes (y), no (n), or quit (q)."
                    ;;
            esac
        done
    done
}

# --- Function to check for g++ and prompt for installation ---
check_gpp_installation() {
    # This function will loop until g++ is found or the user quits.
    while true; do
        local os_type=""
        local gpp_installed=false

        # Determine OS and check for g++
        if [[ "$(uname -s)" == "Darwin" ]]; then
            os_type="macos"
            if xcode-select -p &> /dev/null; then
                gpp_installed=true
            fi
        elif [ -f /etc/os-release ] && grep -qE 'ID=ubuntu|ID=debian' /etc/os-release; then
            os_type="debian_ubuntu"
            if g++ --version &> /dev/null; then
                gpp_installed=true
            fi
        else
            echo "Error: Unsupported operating system."
            echo "This script is compatible with macOS, Debian, and Ubuntu systems."
            exit 1
        fi

        # If g++ is installed, dependencies are satisfied. Exit the function successfully.
        if [ "$gpp_installed" = true ]; then
            return 0
        fi

        # If g++ is missing, inform the user and prompt for action.
        echo "G++ compiler is not installed, which is required for C++ compilation."

        # This prompt loop will only break if the user chooses to install (y) or quit (q).
        while true; do
            read -p "Would you like to install g++? (y/n/quit) " ynq
            case $ynq in
                [Yy]* )
                    # Install g++ based on the determined OS
                    if [[ "$os_type" == "macos" ]]; then
                        echo "Installing Command Line Tools for macOS. A system dialog will appear."
                        echo "Please approve the installation in the dialog to continue."
                        xcode-select --install

                        # Wait for the user to confirm they have completed the installation
                        while true; do
                            read -p "Have you successfully completed the installation? (y/n/quit) " ynq_install
                            case $ynq_install in
                                [Yy]* ) break ;; # Break inner loop to re-check g++
                                [Nn]* ) echo "Please complete the installation in the system dialog to continue." 
                                        continue ;;
                                [Qq]* ) echo "Exiting..."; exit 0 ;;
                                * ) echo "Please answer yes (y), no (n), or quit (q)." ;;
                            esac
                        done

                    elif [[ "$os_type" == "debian_ubuntu" ]]; then
                        echo "Installing the build-essential package..."
                        sudo apt update && sudo apt install -y build-essential
                    fi
                    # After the installation attempt, break the inner prompt loop.
                    # The outer `while true` loop will then re-run the g++ check.
                    break
                    ;;
                [Nn]* )
                    continue
                    ;;
                [Qq]* )
                    echo "Exiting..."
                    exit 0
                    ;;
                * )
                    echo "Please answer yes (y), no (n), or quit (q)."
                    ;;
            esac
        done
    done
}


# --- Function to interactively get and validate LAPACK paths from user ---
prompt_and_validate_lapack_paths() {
    # This function loops until the user provides valid paths for the include and library files
    echo "Please provide the paths to your LAPACK installation."
    while true; do
        # Prompt for the include path
        read -p "Enter the LAPACK include path (e.g., /usr/local/include) or 'quit': " LAPACK_INCLUDE_PATH
        if [[ "$LAPACK_INCLUDE_PATH" == "quit" ]]; then echo "Exiting..."; exit 0; fi

        # Prompt for the library path
        read -p "Enter the LAPACK library path (e.g., /usr/local/lib) or 'quit': " LAPACK_LIB_PATH
        if [[ "$LAPACK_LIB_PATH" == "quit" ]]; then echo "Exiting..."; exit 0; fi

        local include_ok=false
        # Check for the existence of the main LAPACKE header file
        if [[ -f "${LAPACK_INCLUDE_PATH}/lapacke.h" ]]; then
            include_ok=true
        else
            echo "Verification failed: 'lapacke.h' not found in '${LAPACK_INCLUDE_PATH}'."
        fi

        local lib_ok=false
        # Check for static (.a), shared (.so), or macOS dynamic (.dylib) libraries
        if [[ -f "${LAPACK_LIB_PATH}/liblapack.a" || -f "${LAPACK_LIB_PATH}/liblapack.so" || -f "${LAPACK_LIB_PATH}/liblapack.dylib" ]]; then
            lib_ok=true
        else
            echo "Verification failed: No LAPACK library file (e.g., liblapack.a, .so, .dylib) found in '${LAPACK_LIB_PATH}'."
        fi

        # If both paths are valid, exit the loop
        if [[ "$include_ok" == true && "$lib_ok" == true ]]; then
            echo "LAPACK paths successfully verified."
            return 0 # Success
        else
            echo "Invalid paths provided. Please check your directories and try again."
        fi
    done
}

# --- Function to guide user through LAPACK installation and setup ---
setup_lapack_interactive() {
    # This function handles the entire interactive setup for LAPACK
    while true; do
        read -p "Do you have LAPACK installed on your system? (y/n/quit) " ynq
        case $ynq in
            [Yy]* )
                # If yes, proceed directly to path validation
                if prompt_and_validate_lapack_paths; then
                    return 0 # Success
                fi
                ;;
            [Nn]* )
                # If no, provide instructions and wait for the user to install it
                echo "Please install LAPACK. You can find instructions at: https://netlib.org/lapack/"
                while true; do
                    read -p "Have you installed LAPACK now? (y/n/quit) " ynq_install
                    case $ynq_install in
                        [Yy]* )
                            # Once they confirm installation, break to the path validation
                            break
                            ;;
                        [Nn]* ) 
                            echo "Please install LAPACK to continue."
                            ;;
                        [Qq]* ) 
                            echo "Exiting..."; exit 0
                            ;;
                        * ) 
                            echo "Please answer yes (y), no (n), or quit (q)."
                            ;;
                    esac
                done
                # After breaking the inner loop, re-run the validation
                if prompt_and_validate_lapack_paths; then
                    return 0 # Success
                fi
                ;;
            [Qq]* ) 
                echo "Exiting..."; exit 0
                ;;
            * ) 
                echo "Please answer yes (y), no (n), or quit (q)."
                ;;
        esac
    done
}


# --- Function to verify LAPACK paths loaded from config ---
verify_lapack_config() {
    # Checks if the paths sourced from the config file are valid
    if [[ -z "$LAPACK_INCLUDE_PATH" || -z "$LAPACK_LIB_PATH" ]]; then return 1; fi
    if [[ ! -f "${LAPACK_INCLUDE_PATH}/lapacke.h" ]]; then return 1; fi
    if [[ ! -f "${LAPACK_LIB_PATH}/liblapack.a" && ! -f "${LAPACK_LIB_PATH}/liblapack.so" && ! -f "${LAPACK_LIB_PATH}/liblapack.dylib" ]]; then return 1; fi
    
    return 0 # Success
}

# --- Function to verify required project files ---
verify_required_files() {
    # Ensures all necessary C++ and Python source files are present
    echo "Verifying required project files..."
    local missing_files=()
    local required_files=("recursiveMatrix846.cpp" "plotNormalize.py" "graphsAdjacency.py" "gap.py")
    
    for file in "${required_files[@]}"; do
        if [ ! -f "${SCRIPT_DIR}/${file}" ]; then
            missing_files+=("$file")
        fi
    done

    if [ ${#missing_files[@]} -ne 0 ]; then
        echo "Error: The following required files were not found in the project directory:"
        printf -- "- %s\n" "${missing_files[@]}"
        echo "Please ensure all project files are in the same directory."
        exit 1
    fi
}

# --- Main Script ---
echo "Welcome to the Bellaterra Automaton Project!"

# --- Setup and Verification ---
get_script_directory
verify_required_files
check_gpp_installation
check_python_dependencies

CONFIG_FILE="${SCRIPT_DIR}/LAPACK_CONFIG"
config_is_valid=false

# Check if a config file exists and if the paths within it are valid
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
    if verify_lapack_config; then
        config_is_valid=true
    else
        echo "LAPACK configuration file found, but the paths are incorrect or directories are missing."
    fi
fi

# If config is not valid (either file is missing or paths are bad), trigger the setup process
if ! $config_is_valid; then
    echo "Starting LAPACK dependency check..."
    if ! setup_lapack_interactive; then
        echo "LAPACK setup failed. Exiting."
        exit 1
    fi
    save_config # Save the newly validated paths
fi

# --- Execution Workflow ---
clean_previous_data
echo "Starting the main workflow..."

# Compile the C++ code using the verified LAPACK paths
echo "Compiling C++ source file: recursiveMatrix846.cpp"
g++ -std=c++17 -o "${SCRIPT_DIR}/a" "${SCRIPT_DIR}/recursiveMatrix846.cpp" \
    -I"${LAPACK_INCLUDE_PATH}" -L"${LAPACK_LIB_PATH}" \
    -llapacke -llapack -lblas -lm

# Check if compilation was successful
if [ $? -ne 0 ]; then
    echo "C++ compilation failed. Check your LAPACK installation and paths."
    exit 1
fi
echo "C++ compilation successful."

# Run the C++ executable
echo "Running C++ executable..."
"${SCRIPT_DIR}/a"
if [ $? -ne 0 ]; then echo "C++ run failed."; exit 1; fi
rm "${SCRIPT_DIR}/a" # Clean up the executable

# Run the Python scripts for plotting and analysis
echo "Running Python script: plotNormalize.py"
python3 "${SCRIPT_DIR}/plotNormalize.py"
if [ $? -ne 0 ]; then echo "plotNormalize.py run failed."; exit 1; fi

echo "Running Python script: graphsAdjacency.py"
python3 "${SCRIPT_DIR}/graphsAdjacency.py"
if [ $? -ne 0 ]; then echo "graphsAdjacency.py run failed."; exit 1; fi

echo "Running Python script: gap.py"
python3 "${SCRIPT_DIR}/gap.py"
if [ $? -ne 0 ]; then echo "gap.py run failed."; exit 1; fi

echo "Project workflow completed successfully!"